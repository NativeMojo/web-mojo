/**
 * Vite Plugin for MOJO Template Compilation
 * Automatically compiles .mst templates into a JavaScript module
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Configuration
const TEMPLATE_EXTENSIONS = ['.mst', '.html'];
const SOURCE_DIRS = [
  'src/auth/pages',
  'src/components',
  'src/pages',
  'src/templates'
];
const OUTPUT_FILE = 'src/templates.js';

/**
 * Find all template files in the specified directories
 */
function findTemplateFiles(rootDir) {
  const templates = new Map();
  
  SOURCE_DIRS.forEach(dir => {
    const fullPath = path.join(rootDir, dir);
    if (!fs.existsSync(fullPath)) {
      return;
    }
    
    walkDirectory(fullPath, (filePath) => {
      const ext = path.extname(filePath);
      if (TEMPLATE_EXTENSIONS.includes(ext)) {
        // Create a logical key for the template
        const relativePath = path.relative(rootDir, filePath);
        const key = relativePath
          .replace(/\\/g, '/')  // Normalize path separators
          .replace(/^src\//, ''); // Remove src/ prefix
        
        // Read the template content
        const content = fs.readFileSync(filePath, 'utf8');
        templates.set(key, content);
      }
    });
  });
  
  return templates;
}

/**
 * Walk directory recursively
 */
function walkDirectory(dir, callback) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      walkDirectory(filePath, callback);
    } else {
      callback(filePath);
    }
  });
}

/**
 * Escape template content for JavaScript string
 */
function escapeTemplate(content) {
  return content
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');
}

/**
 * Generate the JavaScript module content
 */
function generateModule(templates) {
  const lines = [
    '/**',
    ' * Auto-generated template module',
    ' * Generated by vite-plugin-templates',
    ' * Generated: ' + new Date().toISOString(),
    ' * Contains all framework templates compiled as JavaScript strings',
    ' */',
    '',
    '// Template registry',
    'const templates = {};',
    ''
  ];
  
  // Add each template
  templates.forEach((content, key) => {
    lines.push(`// Template: ${key}`);
    lines.push(`templates['${key}'] = \`${escapeTemplate(content)}\`;`);
    lines.push('');
  });
  
  // Add exports
  lines.push('// Export templates');
  lines.push('export default templates;');
  lines.push('');
  
  // Add convenience exports for common templates
  templates.forEach((content, key) => {
    // Create a valid JavaScript identifier from the key
    const exportName = key
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/^(\d)/, '_$1')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
    
    if (exportName && exportName !== 'default') {
      lines.push(`export const ${exportName} = templates['${key}'];`);
    }
  });
  
  lines.push('');
  
  // Add helper functions
  lines.push('// Helper functions');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get a template by key');
  lines.push(' * @param {string} key - Template key (e.g., "auth/pages/LoginPage.mst")');
  lines.push(' * @returns {string|undefined} Template content or undefined if not found');
  lines.push(' */');
  lines.push('export function getTemplate(key) {');
  lines.push('  // Handle different path formats');
  lines.push('  const normalizedKey = key');
  lines.push('    .replace(/^\\//, "")  // Remove leading slash');
  lines.push('    .replace(/^src\\//, "")  // Remove src/ prefix');
  lines.push('    .replace(/\\\\/g, "/");  // Normalize path separators');
  lines.push('  ');
  lines.push('  return templates[normalizedKey] || templates[key];');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check if a template exists');
  lines.push(' * @param {string} key - Template key');
  lines.push(' * @returns {boolean} True if template exists');
  lines.push(' */');
  lines.push('export function hasTemplate(key) {');
  lines.push('  return getTemplate(key) !== undefined;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get all template keys');
  lines.push(' * @returns {string[]} Array of template keys');
  lines.push(' */');
  lines.push('export function getTemplateKeys() {');
  lines.push('  return Object.keys(templates);');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get template count');
  lines.push(' * @returns {number} Number of templates');
  lines.push(' */');
  lines.push('export function getTemplateCount() {');
  lines.push('  return Object.keys(templates).length;');
  lines.push('}');
  
  // Add HMR support
  lines.push('');
  lines.push('// Hot Module Replacement support');
  lines.push('if (import.meta.hot) {');
  lines.push('  import.meta.hot.accept();');
  lines.push('}');
  
  return lines.join('\n');
}

/**
 * Compile templates and write to file
 */
function compileTemplates(rootDir) {
  const templates = findTemplateFiles(rootDir);
  
  if (templates.size === 0) {
    console.warn('[vite-plugin-templates] No templates found');
    return false;
  }
  
  const moduleContent = generateModule(templates);
  const outputPath = path.join(rootDir, OUTPUT_FILE);
  
  // Check if content has changed
  let shouldWrite = true;
  if (fs.existsSync(outputPath)) {
    const existingContent = fs.readFileSync(outputPath, 'utf8');
    // Compare without the timestamp line
    const existingWithoutTimestamp = existingContent.replace(/Generated: .+/, 'Generated: [TIMESTAMP]');
    const newWithoutTimestamp = moduleContent.replace(/Generated: .+/, 'Generated: [TIMESTAMP]');
    shouldWrite = existingWithoutTimestamp !== newWithoutTimestamp;
  }
  
  if (shouldWrite) {
    fs.writeFileSync(outputPath, moduleContent, 'utf8');
    console.log(`[vite-plugin-templates] Compiled ${templates.size} templates to ${OUTPUT_FILE}`);
    return true;
  }
  
  return false;
}

/**
 * MOJO Templates Vite Plugin
 */
export default function mojoTemplatesPlugin(options = {}) {
  const {
    sourceDirs = SOURCE_DIRS,
    extensions = TEMPLATE_EXTENSIONS,
    outputFile = OUTPUT_FILE,
    watch = true
  } = options;
  
  let rootDir;
  let server;
  
  return {
    name: 'mojo-templates',
    
    configResolved(config) {
      rootDir = config.root;
    },
    
    buildStart() {
      // Compile templates on build start
      compileTemplates(rootDir);
    },
    
    configureServer(_server) {
      server = _server;
      
      if (!watch) return;
      
      // Watch template directories for changes
      const templateDirs = sourceDirs.map(dir => path.join(rootDir, dir));
      
      // Watch for template file changes
      server.watcher.add(templateDirs);
      
      // Handle template file changes
      server.watcher.on('change', (file) => {
        if (extensions.some(ext => file.endsWith(ext))) {
          console.log(`[vite-plugin-templates] Template changed: ${path.relative(rootDir, file)}`);
          
          // Recompile templates
          const changed = compileTemplates(rootDir);
          
          if (changed) {
            // Trigger HMR for the templates module
            const module = server.moduleGraph.getModuleById(
              path.join(rootDir, outputFile)
            );
            
            if (module) {
              server.moduleGraph.invalidateModule(module);
              server.ws.send({
                type: 'full-reload',
                path: '*'
              });
            }
          }
        }
      });
      
      // Handle new template files
      server.watcher.on('add', (file) => {
        if (extensions.some(ext => file.endsWith(ext))) {
          console.log(`[vite-plugin-templates] New template added: ${path.relative(rootDir, file)}`);
          compileTemplates(rootDir);
          
          // Trigger HMR
          const module = server.moduleGraph.getModuleById(
            path.join(rootDir, outputFile)
          );
          
          if (module) {
            server.moduleGraph.invalidateModule(module);
            server.ws.send({
              type: 'full-reload',
              path: '*'
            });
          }
        }
      });
      
      // Handle deleted template files
      server.watcher.on('unlink', (file) => {
        if (extensions.some(ext => file.endsWith(ext))) {
          console.log(`[vite-plugin-templates] Template deleted: ${path.relative(rootDir, file)}`);
          compileTemplates(rootDir);
          
          // Trigger HMR
          const module = server.moduleGraph.getModuleById(
            path.join(rootDir, outputFile)
          );
          
          if (module) {
            server.moduleGraph.invalidateModule(module);
            server.ws.send({
              type: 'full-reload',
              path: '*'
            });
          }
        }
      });
    },
    
    handleHotUpdate({ file, server }) {
      // If a template file changes, invalidate the templates module
      if (extensions.some(ext => file.endsWith(ext))) {
        const templateModule = server.moduleGraph.getModuleById(
          path.join(rootDir, outputFile)
        );
        
        if (templateModule) {
          return [templateModule];
        }
      }
    }
  };
}

// Export for use as both default and named export
export { mojoTemplatesPlugin };